

<!DOCTYPE html>
<html class="writer-html5" lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ebcpy.data_types &mdash; ebcpy 0.5.4 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css" />
      <link rel="stylesheet" type="text/css" href="../../_static/autodoc_pydantic.css" />

  
      <script src="../../_static/jquery.js"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
      <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
      <script src="../../_static/doctools.js"></script>
      <script src="../../_static/sphinx_highlight.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            ebcpy
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../code/modules.html">ebcpy</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Contribution.html">Contribute as a user</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Contribution.html#contribute-as-a-developer">Contribute as a developer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Reproduction.html">Reproducibility of research</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../version_his.html">Version History</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">ebcpy</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">ebcpy.data_types</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for ebcpy.data_types</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This module provides useful classes for all ebcpy.</span>
<span class="sd">Every data_type class should include every parameter</span>
<span class="sd">other classes like optimization etc. may need. The checking</span>
<span class="sd">of correct input is especially relevant here as the correct</span>
<span class="sd">format of data-types will prevent errors during simulations,</span>
<span class="sd">optimization etc.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">os</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pathlib</span><span class="w"> </span><span class="kn">import</span> <span class="n">Path</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">List</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Any</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">datetime</span><span class="w"> </span><span class="kn">import</span> <span class="n">datetime</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pandas.core.internals</span><span class="w"> </span><span class="kn">import</span> <span class="n">BlockManager</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">ebcpy.modelica.simres</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sr</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">ebcpy</span><span class="w"> </span><span class="kn">import</span> <span class="n">preprocessing</span>

<span class="c1"># pylint: disable=I1101</span>
<span class="c1"># pylint: disable=too-many-ancestors</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;TimeSeries&#39;</span><span class="p">,</span>
           <span class="s1">&#39;TimeSeriesData&#39;</span><span class="p">,</span>
           <span class="s1">&#39;numeric_indexes&#39;</span><span class="p">,</span>
           <span class="s1">&#39;datetime_indexes&#39;</span><span class="p">]</span>

<span class="n">numeric_index_dtypes</span> <span class="o">=</span> <span class="p">[</span>
    <span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">dtype</span> <span class="k">for</span> <span class="n">dtype</span> <span class="ow">in</span>
    <span class="p">[</span><span class="s2">&quot;int8&quot;</span><span class="p">,</span> <span class="s2">&quot;int16&quot;</span><span class="p">,</span> <span class="s2">&quot;int32&quot;</span><span class="p">,</span> <span class="s2">&quot;int64&quot;</span><span class="p">,</span>
     <span class="s2">&quot;uint8&quot;</span><span class="p">,</span> <span class="s2">&quot;uint16&quot;</span><span class="p">,</span> <span class="s2">&quot;uint32&quot;</span><span class="p">,</span> <span class="s2">&quot;uint64&quot;</span><span class="p">,</span>
     <span class="s2">&quot;float32&quot;</span><span class="p">,</span> <span class="s2">&quot;float64&quot;</span><span class="p">]</span>
<span class="p">]</span>

<span class="n">datetime_indexes</span> <span class="o">=</span> <span class="p">[</span>
    <span class="n">pd</span><span class="o">.</span><span class="n">DatetimeIndex</span>
<span class="p">]</span>


<span class="k">def</span><span class="w"> </span><span class="nf">index_is_numeric</span><span class="p">(</span><span class="n">index</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Check if pandas Index is numeric&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">RangeIndex</span><span class="p">)</span> <span class="ow">or</span> <span class="n">index</span><span class="o">.</span><span class="n">dtype</span> <span class="ow">in</span> <span class="n">numeric_index_dtypes</span>


<div class="viewcode-block" id="TimeSeriesData"><a class="viewcode-back" href="../../code/ebcpy.html#ebcpy.data_types.TimeSeriesData">[docs]</a><span class="k">class</span><span class="w"> </span><span class="nc">TimeSeriesData</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Most data related to energy and building</span>
<span class="sd">    climate related problems is time-variant.</span>

<span class="sd">    Class for handling time series data using a pandas dataframe.</span>
<span class="sd">    This class works file-based and makes the import of different</span>
<span class="sd">    file-types into a pandas DataFrame more user-friendly.</span>
<span class="sd">    Furthermore, functions to support multi-indexing are provided to</span>
<span class="sd">    efficiently handle variable passed processing and provide easy</span>
<span class="sd">    visualization and preprocessing access.</span>

<span class="sd">    :param str,os.path.normpath,pd.DataFrame data:</span>
<span class="sd">        Filepath ending with either .hdf, .mat, .csv, .parquet,</span>
<span class="sd">        or .parquet.COMPRESSION_NAME containing</span>
<span class="sd">        time-dependent data to be loaded as a pandas.DataFrame.</span>
<span class="sd">        Alternative option is to pass a DataFrame directly.</span>
<span class="sd">    :keyword str key:</span>
<span class="sd">        Name of the table in a .hdf-file if the file</span>
<span class="sd">        contains multiple tables.</span>
<span class="sd">    :keyword str sep:</span>
<span class="sd">        separator for the use of a csv file. If none is provided,</span>
<span class="sd">        a comma (&quot;,&quot;) is used as a default value.</span>
<span class="sd">        See pandas.read_csv() docs for further information.</span>
<span class="sd">    :keyword int, list header:</span>
<span class="sd">        Header columns for .csv files.</span>
<span class="sd">        See pandas.read_csv() docs for further information.</span>
<span class="sd">        Default is first row (0).</span>
<span class="sd">    :keyword int,str index_col:</span>
<span class="sd">        Column to be used as index in .csv files.</span>
<span class="sd">        See pandas.read_csv() docs for further information.</span>
<span class="sd">        Default is first column (0).</span>
<span class="sd">    :keyword str sheet_name:</span>
<span class="sd">        Name of the sheet you want to load data from. Required keyword</span>
<span class="sd">        argument when loading a xlsx-file.</span>
<span class="sd">    :keyword str default_tag:</span>
<span class="sd">        Which value to use as tag. Default is &#39;raw&#39;</span>
<span class="sd">    :keyword str engine:</span>
<span class="sd">        Chose the engine for reading .parquet files. Default is &#39;pyarrow&#39;</span>
<span class="sd">        Other option is &#39;fastparquet&#39; (python&gt;=3.9).</span>
<span class="sd">    :keyword list variable_names:</span>
<span class="sd">        List of variable names to load from .mat file. If you</span>
<span class="sd">        know which variables you want to plot, this may speed up</span>
<span class="sd">        loading significantly, and reduce memory size drastically.</span>
<span class="sd">        You can also supply wildcard patterns (e.g. &quot;*wall.layer[*].T&quot;, etc.)</span>
<span class="sd">        to match multiple variables at once.</span>

<span class="sd">    Examples:</span>

<span class="sd">    First let&#39;s see the usage for a common dataframe.</span>

<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; import pandas as pd</span>
<span class="sd">    &gt;&gt;&gt; from ebcpy import TimeSeriesData</span>
<span class="sd">    &gt;&gt;&gt; df = pd.DataFrame({&quot;my_variable&quot;: np.random.rand(5)})</span>
<span class="sd">    &gt;&gt;&gt; tsd = TimeSeriesData(df)</span>
<span class="sd">    &gt;&gt;&gt; tsd.to_datetime_index()</span>
<span class="sd">    &gt;&gt;&gt; tsd.save(&quot;my_new_data.csv&quot;)</span>

<span class="sd">    Now, let&#39;s load the recently created file.</span>
<span class="sd">    As we just created the data, we specify the tag</span>
<span class="sd">    &#39;sim&#39; to indicate it is some sort of simulated value.</span>

<span class="sd">    &gt;&gt;&gt; tsd = TimeSeriesData(&quot;my_new_data.csv&quot;, tag=&#39;sim&#39;)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># normal properties</span>
    <span class="n">_metadata</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s2">&quot;_filepath&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_loader_kwargs&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_default_tag&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_multi_col_names&quot;</span>
    <span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize class-objects and check correct input.&quot;&quot;&quot;</span>
        <span class="c1"># Initialize as default</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_filepath</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_loader_kwargs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_multi_col_names</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Variables&quot;</span><span class="p">,</span> <span class="s2">&quot;Tags&quot;</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_default_tag</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;default_tag&quot;</span><span class="p">,</span> <span class="s2">&quot;raw&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_default_tag</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid type for default_tag! Expected &#39;str&#39; but &quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;received </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_default_tag</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Two possibles inputs. first argument is actually data provided by pandas</span>
        <span class="c1"># and kwargs hold further information or is it an actual filepath.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">BlockManager</span><span class="p">):</span>
            <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">Path</span><span class="p">)):</span>
            <span class="n">_df_loaded</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span>
                                      <span class="n">index</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;index&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                                      <span class="n">columns</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;columns&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                                      <span class="n">dtype</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;dtype&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                                      <span class="n">copy</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;copy&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">file</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_loader_kwargs</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">_df_loaded</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load_df_from_file</span><span class="p">(</span><span class="n">file</span><span class="o">=</span><span class="n">file</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_filepath</span> <span class="o">=</span> <span class="n">file</span>

        <span class="k">if</span> <span class="n">_df_loaded</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">nlevels</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># Check if first level is named Tags.</span>
            <span class="c1"># If so, don&#39;t create MultiIndex-DF as the method is called by the pd constructor</span>
            <span class="k">if</span> <span class="n">_df_loaded</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">name</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_multi_col_names</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">multi_col</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">MultiIndex</span><span class="o">.</span><span class="n">from_product</span><span class="p">(</span>
                    <span class="p">[</span><span class="n">_df_loaded</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_default_tag</span><span class="p">]],</span>
                    <span class="n">names</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_multi_col_names</span>
                <span class="p">)</span>
                <span class="n">_df_loaded</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="n">multi_col</span>

        <span class="k">elif</span> <span class="n">_df_loaded</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">nlevels</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">_df_loaded</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">names</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_multi_col_names</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Loaded dataframe has a different 2-Level &quot;</span>
                                <span class="s2">&quot;header format than it is supported by this &quot;</span>
                                <span class="s2">&quot;class. The names have to match.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Only DataFrames with Multi-Columns with 2 &quot;</span>
                            <span class="s2">&quot;Levels are supported by this class.&quot;</span><span class="p">)</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">_df_loaded</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_constructor</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Overwrite constructor method according to:</span>
<span class="sd">        https://pandas.pydata.org/pandas-docs/stable/development/extending.html#extending-subclassing-pandas&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">TimeSeriesData</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_constructor_sliced</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Overwrite constructor method according to:</span>
<span class="sd">        https://pandas.pydata.org/pandas-docs/stable/development/extending.html#extending-subclassing-pandas&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">TimeSeries</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">filepath</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the filepath associated with the time series data&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filepath</span>

    <span class="nd">@filepath</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">filepath</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filepath</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set the filepath associated with the time series data&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_filepath</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">filepath</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">default_tag</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the default of time series data object&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_default_tag</span>

    <span class="nd">@default_tag</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">default_tag</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tag</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set the default_tag of the time series data object</span>
<span class="sd">        :param tag: new tag</span>
<span class="sd">        :type tag: String</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tag</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid type for default_tag! Expected &#39;str&#39; but &quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;received </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">tag</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">tag</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_tags</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Tag &#39;</span><span class="si">{</span><span class="n">tag</span><span class="si">}</span><span class="s2">&#39; does not exist for current data set!&quot;</span>
                           <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2"> Available tags: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_tags</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_default_tag</span> <span class="o">=</span> <span class="n">tag</span>

<div class="viewcode-block" id="TimeSeriesData.save"><a class="viewcode-back" href="../../code/ebcpy.html#ebcpy.data_types.TimeSeriesData.save">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">save</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filepath</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Save the current time-series-data into the given file-format.</span>
<span class="sd">        Currently supported are .hdf, which is an easy and fast storage,</span>
<span class="sd">        and, .csv is supported as an easy-readable option.</span>
<span class="sd">        Also, .parquet, and with additional compression .parquet.COMPRESSION_NAME</span>
<span class="sd">        are supported. Compressions could be gzip, brotli or snappy. For all possible</span>
<span class="sd">        compressions see the documentation of the parquet engines.</span>
<span class="sd">        For a small comparison of these data formats see https://github.com/RWTH-EBC/ebcpy/issues/81</span>

<span class="sd">        :param str,os.path.normpath filepath:</span>
<span class="sd">            Filepath were to store the data. Either .hdf, .csv, .parquet</span>
<span class="sd">            or .parquet.COMPRESSION_NAME has to be the file-ending.</span>
<span class="sd">            Default is current filepath of class.</span>
<span class="sd">        :keyword str key:</span>
<span class="sd">            Necessary keyword-argument for saving a .hdf-file.</span>
<span class="sd">            Specifies the key of the table in the .hdf-file.</span>
<span class="sd">        :keyword str sep:</span>
<span class="sd">            Separator used for saving as .csv. Default is &#39;,&#39;.</span>
<span class="sd">        :keyword str engine:</span>
<span class="sd">            Chose the engine for reading .parquet files. Default is &#39;pyarrow&#39;</span>
<span class="sd">            Other option is &#39;fastparquet&#39; (python&gt;=3.9).</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># If new settings are needed, update existing ones</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_loader_kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="c1"># Set filepath if not given</span>
        <span class="k">if</span> <span class="n">filepath</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">filepath</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filepath</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">filepath</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">filepath</span><span class="p">)</span>
        <span class="c1"># Check if filepath is still None (if no filepath was used in init)</span>
        <span class="k">if</span> <span class="n">filepath</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Current TimeSeriesData instance &quot;</span>
                             <span class="s2">&quot;has no filepath, please specify one.&quot;</span><span class="p">)</span>
        <span class="c1"># Save based on file suffix</span>
        <span class="k">if</span> <span class="n">filepath</span><span class="o">.</span><span class="n">suffix</span> <span class="o">==</span> <span class="s2">&quot;.hdf&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="s2">&quot;key&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s2">&quot;Argument &#39;key&#39; must be &quot;</span>
                               <span class="s2">&quot;specified to save a .hdf file&quot;</span><span class="p">)</span>
            <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">to_hdf</span><span class="p">(</span><span class="n">filepath</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;key&quot;</span><span class="p">))</span>

        <span class="k">elif</span> <span class="n">filepath</span><span class="o">.</span><span class="n">suffix</span> <span class="o">==</span> <span class="s2">&quot;.csv&quot;</span><span class="p">:</span>
            <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">filepath</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;sep&quot;</span><span class="p">,</span> <span class="s2">&quot;,&quot;</span><span class="p">))</span>
        <span class="k">elif</span> <span class="s2">&quot;.parquet&quot;</span> <span class="ow">in</span> <span class="n">filepath</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
            <span class="n">parquet_split</span> <span class="o">=</span> <span class="n">filepath</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;.parquet&quot;</span><span class="p">)</span>
            <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">to_parquet</span><span class="p">(</span>
                <span class="n">filepath</span><span class="p">,</span> <span class="n">engine</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;engine&#39;</span><span class="p">,</span> <span class="s1">&#39;pyarrow&#39;</span><span class="p">),</span>
                <span class="n">compression</span><span class="o">=</span><span class="n">parquet_split</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">:]</span> <span class="k">if</span> <span class="n">parquet_split</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
                <span class="n">index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Given file-format is not supported.&quot;</span>
                            <span class="s2">&quot;You can only store TimeSeriesData as .hdf, .csv, .parquet, &quot;</span>
                            <span class="s2">&quot;and .parquet.COMPRESSION_NAME with additional compression options&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeriesData.to_df"><a class="viewcode-back" href="../../code/ebcpy.html#ebcpy.data_types.TimeSeriesData.to_df">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">to_df</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">force_single_index</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the dataframe version of the current TimeSeriesData object.</span>
<span class="sd">        If all tags are equal, the tags are dropped.</span>
<span class="sd">        Else, the object is just converted.</span>

<span class="sd">        :param bool force_single_index:</span>
<span class="sd">            If True (not the default), the conversion to a standard</span>
<span class="sd">            DataFrame with a single index column (only variable names)</span>
<span class="sd">            is only done if no variable contains multiple tags.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_variables_with_multiple_tags</span><span class="p">())</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">droplevel</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">force_single_index</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span>
                <span class="s2">&quot;Can&#39;t automatically drop all tags &quot;</span>
                <span class="s2">&quot;as the following variables contain multiple tags: &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="s1">&#39; ,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_variables_with_multiple_tags</span><span class="p">())</span><span class="si">}</span><span class="s2">. &quot;</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>

    <span class="k">def</span><span class="w"> </span><span class="nf">_load_df_from_file</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Function to load a given filepath into a dataframe&quot;&quot;&quot;</span>
        <span class="c1"># Check whether the file exists</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">file</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">FileNotFoundError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;The given filepath </span><span class="si">{</span><span class="n">file</span><span class="si">}</span><span class="s2"> could not be opened&quot;</span><span class="p">)</span>

        <span class="c1"># Open based on file suffix.</span>
        <span class="c1"># Currently, hdf, csv, and Modelica result files (mat) are supported.</span>
        <span class="k">if</span> <span class="n">file</span><span class="o">.</span><span class="n">suffix</span> <span class="o">==</span> <span class="s2">&quot;.hdf&quot;</span><span class="p">:</span>
            <span class="c1"># Load the current file as a hdf to a dataframe.</span>
            <span class="c1"># As specifying the key can be a problem, the user will</span>
            <span class="c1"># get all keys of the file if one is necessary but not provided.</span>
            <span class="n">key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_loader_kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;key&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
                <span class="n">key</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># Avoid cryptic error in pandas by converting empty string to None</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_hdf</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">key</span><span class="p">)</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="ne">KeyError</span><span class="p">)</span> <span class="k">as</span> <span class="n">error</span><span class="p">:</span>
                <span class="n">keys</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">get_keys_of_hdf_file</span><span class="p">(</span><span class="n">file</span><span class="p">))</span>
                <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;key must be provided when HDF5 file contains multiple datasets. &quot;</span>
                               <span class="sa">f</span><span class="s2">&quot;Here are all keys in the given hdf-file: </span><span class="si">{</span><span class="n">keys</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">error</span>
        <span class="k">elif</span> <span class="n">file</span><span class="o">.</span><span class="n">suffix</span> <span class="o">==</span> <span class="s2">&quot;.csv&quot;</span><span class="p">:</span>
            <span class="c1"># Check if file was previously a TimeSeriesData object</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">_f</span><span class="p">:</span>
                <span class="n">lines</span> <span class="o">=</span> <span class="p">[</span><span class="n">_f</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">)]</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">lines</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_multi_col_names</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">and</span>
                        <span class="n">lines</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_multi_col_names</span><span class="p">[</span><span class="mi">1</span><span class="p">])):</span>
                    <span class="n">_hea_def</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">_hea_def</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span>
                <span class="n">file</span><span class="p">,</span>
                <span class="n">sep</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_loader_kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;sep&quot;</span><span class="p">,</span> <span class="s2">&quot;,&quot;</span><span class="p">),</span>
                <span class="n">index_col</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_loader_kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;index_col&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
                <span class="n">header</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_loader_kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;header&quot;</span><span class="p">,</span> <span class="n">_hea_def</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">file</span><span class="o">.</span><span class="n">suffix</span> <span class="o">==</span> <span class="s2">&quot;.mat&quot;</span><span class="p">:</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">sr</span><span class="o">.</span><span class="n">mat_to_pandas</span><span class="p">(</span>
                <span class="n">fname</span><span class="o">=</span><span class="n">file</span><span class="p">,</span>
                <span class="n">with_unit</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">names</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_loader_kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;variable_names&quot;</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">file</span><span class="o">.</span><span class="n">suffix</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;.xlsx&#39;</span><span class="p">,</span> <span class="s1">&#39;.xls&#39;</span><span class="p">,</span> <span class="s1">&#39;.odf&#39;</span><span class="p">,</span> <span class="s1">&#39;.ods&#39;</span><span class="p">,</span> <span class="s1">&#39;.odt&#39;</span><span class="p">]:</span>
            <span class="n">sheet_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_loader_kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;sheet_name&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">sheet_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s2">&quot;sheet_name is a required keyword argument to load xlsx-files.&quot;</span>
                               <span class="s2">&quot;Please pass a string to specify the name &quot;</span>
                               <span class="s2">&quot;of the sheet you want to load.&quot;</span><span class="p">)</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_excel</span><span class="p">(</span><span class="n">io</span><span class="o">=</span><span class="n">file</span><span class="p">,</span> <span class="n">sheet_name</span><span class="o">=</span><span class="n">sheet_name</span><span class="p">)</span>
        <span class="k">elif</span> <span class="s2">&quot;.parquet&quot;</span> <span class="ow">in</span> <span class="n">file</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_parquet</span><span class="p">(</span><span class="n">path</span><span class="o">=</span><span class="n">file</span><span class="p">,</span> <span class="n">engine</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_loader_kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;engine&#39;</span><span class="p">,</span> <span class="s1">&#39;pyarrow&#39;</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Only .hdf, .csv, .xlsx and .mat are supported!&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">datetime_indexes</span><span class="p">))</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">index_is_numeric</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">df</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DatetimeIndex</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Given data has index of type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="p">)</span><span class="si">}</span><span class="s2">. &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;Currently only numeric indexes and the following are supported:&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="s1">&#39; ,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">idx</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">RangeIndex</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">datetime_indexes</span><span class="p">])</span><span class="si">}</span><span class="s2"> &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;Automatic conversion to pd.DateTimeIndex failed&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;see error above.&quot;</span>
                <span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">err</span>
        <span class="k">return</span> <span class="n">df</span>

<div class="viewcode-block" id="TimeSeriesData.get_variable_names"><a class="viewcode-back" href="../../code/ebcpy.html#ebcpy.data_types.TimeSeriesData.get_variable_names">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">get_variable_names</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return an alphabetically sorted list of all variables</span>

<span class="sd">        :return: List[str]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">get_level_values</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">unique</span><span class="p">())</span></div>

<div class="viewcode-block" id="TimeSeriesData.get_variables_with_multiple_tags"><a class="viewcode-back" href="../../code/ebcpy.html#ebcpy.data_types.TimeSeriesData.get_variables_with_multiple_tags">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">get_variables_with_multiple_tags</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return an alphabetically sorted list of all variables</span>
<span class="sd">        that contain more than one tag.</span>

<span class="sd">        :return: List[str]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">var_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">get_level_values</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">var_names</span><span class="p">[</span><span class="n">var_names</span><span class="o">.</span><span class="n">duplicated</span><span class="p">()])</span></div>

<div class="viewcode-block" id="TimeSeriesData.get_tags"><a class="viewcode-back" href="../../code/ebcpy.html#ebcpy.data_types.TimeSeriesData.get_tags">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">get_tags</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variable</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return an alphabetically sorted list of all tags</span>

<span class="sd">        :param str variable:</span>
<span class="sd">            If given, tags of this variable are returned</span>

<span class="sd">        :return: List[str]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">variable</span><span class="p">:</span>
            <span class="n">tags</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">variable</span><span class="p">]</span><span class="o">.</span><span class="n">columns</span>
            <span class="k">return</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">tags</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">get_level_values</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">unique</span><span class="p">())</span></div>

<div class="viewcode-block" id="TimeSeriesData.get_columns_by_tag"><a class="viewcode-back" href="../../code/ebcpy.html#ebcpy.data_types.TimeSeriesData.get_columns_by_tag">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">get_columns_by_tag</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                           <span class="n">tag</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                           <span class="n">variables</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                           <span class="n">return_type</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;pandas&#39;</span><span class="p">,</span>
                           <span class="n">drop_level</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returning all columns with defined tag in the form of ndarray.</span>

<span class="sd">        :param str tag:</span>
<span class="sd">            Define the tag which return columns have to</span>
<span class="sd">            match.</span>
<span class="sd">        :param list variables:</span>
<span class="sd">            Besides the given tag, specify the</span>
<span class="sd">            variables names matching the return criteria as well.</span>
<span class="sd">        :param boolean drop_level:</span>
<span class="sd">            If tag should be included in the response.</span>
<span class="sd">            Default is True.</span>
<span class="sd">        :param str return_type:</span>
<span class="sd">            Return format. Options are:</span>
<span class="sd">            - pandas (pd.series)</span>
<span class="sd">            - numpy, scipy, sp, and np (np.array)</span>
<span class="sd">            - control (transposed np.array)</span>
<span class="sd">        :return: ndarray of input signals</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Extract columns</span>
        <span class="k">if</span> <span class="n">variables</span><span class="p">:</span>
            <span class="n">_ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">variables</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_ret</span> <span class="o">=</span> <span class="bp">self</span>

        <span class="n">_ret</span> <span class="o">=</span> <span class="n">_ret</span><span class="o">.</span><span class="n">xs</span><span class="p">(</span><span class="n">tag</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">drop_level</span><span class="o">=</span><span class="n">drop_level</span><span class="p">)</span>

        <span class="c1"># Return based on the given return_type</span>
        <span class="k">if</span> <span class="n">return_type</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;pandas&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_ret</span>
        <span class="k">if</span> <span class="n">return_type</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;numpy&#39;</span><span class="p">,</span> <span class="s1">&#39;scipy&#39;</span><span class="p">,</span> <span class="s1">&#39;sp&#39;</span><span class="p">,</span> <span class="s1">&#39;np&#39;</span><span class="p">]:</span>
            <span class="k">return</span> <span class="n">_ret</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">return_type</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;control&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_ret</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Unknown return type&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeriesData.to_datetime_index"><a class="viewcode-back" href="../../code/ebcpy.html#ebcpy.data_types.TimeSeriesData.to_datetime_index">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">to_datetime_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unit_of_index</span><span class="o">=</span><span class="s2">&quot;s&quot;</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">(),</span> <span class="n">inplace</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert the current index to a float based index using</span>
<span class="sd">        ebcpy.preprocessing.convert_index_to_datetime_index()</span>

<span class="sd">        :param str unit_of_index: default &#39;s&#39;</span>
<span class="sd">            The unit of the given index. Used to convert to</span>
<span class="sd">            total_seconds later on.</span>
<span class="sd">        :param datetime.datetime origin:</span>
<span class="sd">            The reference datetime object for the first index.</span>
<span class="sd">            Default is the current system time.</span>
<span class="sd">        :param bool inplace:</span>
<span class="sd">            If True, performs operation inplace and returns None.</span>
<span class="sd">        :return: df</span>
<span class="sd">            Copy of DataFrame with correct index for usage in this</span>
<span class="sd">            framework.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">preprocessing</span><span class="o">.</span><span class="n">convert_index_to_datetime_index</span><span class="p">(</span><span class="n">df</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
                                                             <span class="n">unit_of_index</span><span class="o">=</span><span class="n">unit_of_index</span><span class="p">,</span>
                                                             <span class="n">origin</span><span class="o">=</span><span class="n">origin</span><span class="p">,</span>
                                                             <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeriesData.to_float_index"><a class="viewcode-back" href="../../code/ebcpy.html#ebcpy.data_types.TimeSeriesData.to_float_index">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">to_float_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">inplace</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert the current index to a float based index using</span>
<span class="sd">        ebcpy.preprocessing.convert_datetime_index_to_float_index()</span>

<span class="sd">        :param float offset:</span>
<span class="sd">            Offset in seconds</span>
<span class="sd">        :param bool inplace:</span>
<span class="sd">            If True, performs operation inplace and returns None.</span>
<span class="sd">        :return: pd.DataFrame df:</span>
<span class="sd">            DataFrame with correct index.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DatetimeIndex</span><span class="p">):</span>
            <span class="k">return</span>

        <span class="k">return</span> <span class="n">preprocessing</span><span class="o">.</span><span class="n">convert_datetime_index_to_float_index</span><span class="p">(</span><span class="n">df</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
                                                                   <span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">,</span>
                                                                   <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeriesData.clean_and_space_equally"><a class="viewcode-back" href="../../code/ebcpy.html#ebcpy.data_types.TimeSeriesData.clean_and_space_equally">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">clean_and_space_equally</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">desired_freq</span><span class="p">,</span> <span class="n">inplace</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Call to the preprocessing function</span>
<span class="sd">        ebcpy.preprocessing.clean_and_space_equally_time_series()</span>
<span class="sd">        See the docstring of this function to know what is happening.</span>

<span class="sd">        :param str desired_freq:</span>
<span class="sd">            Frequency to determine number of elements in processed dataframe.</span>
<span class="sd">            Options are for example:</span>
<span class="sd">            - s: second-based</span>
<span class="sd">            - 5s: Every 5 seconds</span>
<span class="sd">            - 6min: Every 6 minutes</span>
<span class="sd">            This also works for h, d, m, y, ms etc.</span>
<span class="sd">        :param bool inplace:</span>
<span class="sd">            If True, performs operation inplace and returns None.</span>
<span class="sd">        :return: pd.DataFrame</span>
<span class="sd">            Cleaned and equally spaced data-frame</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">preprocessing</span><span class="o">.</span><span class="n">clean_and_space_equally_time_series</span><span class="p">(</span><span class="n">df</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
                                                               <span class="n">desired_freq</span><span class="o">=</span><span class="n">desired_freq</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">df</span></div>

<div class="viewcode-block" id="TimeSeriesData.low_pass_filter"><a class="viewcode-back" href="../../code/ebcpy.html#ebcpy.data_types.TimeSeriesData.low_pass_filter">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">low_pass_filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">crit_freq</span><span class="p">,</span> <span class="n">filter_order</span><span class="p">,</span> <span class="n">variable</span><span class="p">,</span>
                        <span class="n">tag</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">new_tag</span><span class="o">=</span><span class="s2">&quot;low_pass_filter&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Call to the preprocessing function</span>
<span class="sd">        ebcpy.preprocessing.low_pass_filter()</span>
<span class="sd">        See the docstring of this function to know what is happening.</span>

<span class="sd">        :param float crit_freq:</span>
<span class="sd">            The critical frequency or frequencies.</span>
<span class="sd">        :param int filter_order:</span>
<span class="sd">            The order of the filter</span>
<span class="sd">        :param str variable:</span>
<span class="sd">            The variable name to apply the filter to</span>
<span class="sd">        :param str tag:</span>
<span class="sd">            If this variable has more than one tag, specify which one</span>
<span class="sd">        :param str new_tag:</span>
<span class="sd">            The new tag to pass to the variable.</span>
<span class="sd">            Default is &#39;low_pass_filter&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">tag</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">variable</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="n">tag</span><span class="p">)]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>

        <span class="n">result</span> <span class="o">=</span> <span class="n">preprocessing</span><span class="o">.</span><span class="n">low_pass_filter</span><span class="p">(</span>
            <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span>
            <span class="n">filter_order</span><span class="o">=</span><span class="n">filter_order</span><span class="p">,</span>
            <span class="n">crit_freq</span><span class="o">=</span><span class="n">crit_freq</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="n">new_tag</span><span class="p">)]</span> <span class="o">=</span> <span class="n">result</span></div>

<div class="viewcode-block" id="TimeSeriesData.moving_average"><a class="viewcode-back" href="../../code/ebcpy.html#ebcpy.data_types.TimeSeriesData.moving_average">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">moving_average</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">window</span><span class="p">,</span> <span class="n">variable</span><span class="p">,</span>
                       <span class="n">tag</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">new_tag</span><span class="o">=</span><span class="s2">&quot;moving_average&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Call to the preprocessing function</span>
<span class="sd">        ebcpy.preprocessing.moving_average()</span>
<span class="sd">        See the docstring of this function to know what is happening.</span>

<span class="sd">        :param int window:</span>
<span class="sd">            sample rate of input</span>
<span class="sd">        :param str variable:</span>
<span class="sd">            The variable name to apply the filter to</span>
<span class="sd">        :param str tag:</span>
<span class="sd">            If this variable has more than one tag, specify which one</span>
<span class="sd">        :param str new_tag:</span>
<span class="sd">            The new tag to pass to the variable.</span>
<span class="sd">            Default is &#39;low_pass_filter&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">tag</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">variable</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="n">tag</span><span class="p">)]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>

        <span class="n">result</span> <span class="o">=</span> <span class="n">preprocessing</span><span class="o">.</span><span class="n">moving_average</span><span class="p">(</span>
            <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span>
            <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="n">new_tag</span><span class="p">)]</span> <span class="o">=</span> <span class="n">result</span></div>

<div class="viewcode-block" id="TimeSeriesData.number_lines_totally_na"><a class="viewcode-back" href="../../code/ebcpy.html#ebcpy.data_types.TimeSeriesData.number_lines_totally_na">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">number_lines_totally_na</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the number of rows in the given dataframe</span>
<span class="sd">        that are filled with NaN-values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">preprocessing</span><span class="o">.</span><span class="n">number_lines_totally_na</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">frequency</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The frequency of the time series data.</span>
<span class="sd">        Returns&#39;s the mean and the standard deviation of</span>
<span class="sd">        the index.</span>

<span class="sd">        :returns:</span>
<span class="sd">            float: Mean value</span>
<span class="sd">            float: Standard deviation</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">preprocessing</span><span class="o">.</span><span class="n">get_df_index_frequency_mean_and_std</span><span class="p">(</span>
            <span class="n">df_index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="TimeSeries"><a class="viewcode-back" href="../../code/ebcpy.html#ebcpy.data_types.TimeSeries">[docs]</a><span class="k">class</span><span class="w"> </span><span class="nc">TimeSeries</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Overwrites pd.Series to enable correct slicing</span>
<span class="sd">    and expansion in the TimeSeriesData class</span>

<span class="sd">    .. versionadded:: 0.1.7</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_constructor</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Overwrite constructor method according to:</span>
<span class="sd">        https://pandas.pydata.org/pandas-docs/stable/development/extending.html#extending-subclassing-pandas&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">TimeSeries</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_constructor_expanddim</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Overwrite constructor method according to:</span>
<span class="sd">        https://pandas.pydata.org/pandas-docs/stable/development/extending.html#extending-subclassing-pandas&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">TimeSeriesData</span></div>


<span class="k">def</span><span class="w"> </span><span class="nf">get_keys_of_hdf_file</span><span class="p">(</span><span class="n">filepath</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find all keys in a given hdf-file.</span>

<span class="sd">    :param str,os.path.normpath filepath:</span>
<span class="sd">        Path to the .hdf-file</span>
<span class="sd">    :return: list</span>
<span class="sd">        List with all keys in the given file.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># pylint: disable=import-outside-toplevel</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">h5py</span>
        <span class="k">with</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">filepath</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">hdf_file</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">hdf_file</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="s2">&quot;ERROR: Could not obtain keys as h5py is not installed&quot;</span><span class="p">]</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2019, EON EBC.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>